package cc.tkmr.screenmatch.main;

import cc.tkmr.screenmatch.models.Movie;
import cc.tkmr.screenmatch.models.Series;
import cc.tkmr.screenmatch.models.Title;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class MainWithLists {
    public static void main(String[] args) {
//        Movie myMovie = new Movie("Star Wars", 1977);
//        myMovie.evaluateTitle(9.5);
//        myMovie.evaluateTitle(8.5);
//        Movie myMovie2 = new Movie("Lord of the Rings", 2000);
//        myMovie2.evaluateTitle(8.9);
//        myMovie2.evaluateTitle(7.9);
//        Series mySeries = new Series("Game of Thrones", 2011);
//
//        var danielsMovie = new Movie("The Matrix", 1999); // Use var instead of Movie
//        danielsMovie.evaluateTitle(8.7);
//        danielsMovie.evaluateTitle(9.1);

//        ArrayList<Title> titleArrayList = new ArrayList<>(); // or var instead of ArrayList
//        titleArrayList.add(danielsMovie);
//        titleArrayList.add(myMovie);
//        titleArrayList.add(myMovie2);
//        titleArrayList.add(mySeries);

//        for (Title title : titleArrayList) {
//            System.out.println(title.getTitleName());
//            // Avoid instanceof if possible. It is not a good practice nowadays. You may see at legacy code.
//            if (title instanceof Movie movie && movie.calculateAverageTitleRating() > 2) {
//                System.out.println("Rating: " + movie.calculateAverageTitleRating());
//            }
//        }
//        ArrayList<String> artistSearch = new ArrayList<>();
//        artistSearch.add("Michael");
//        artistSearch.add("Dave");
//        artistSearch.add("Matt");
//        artistSearch.add("Anthony");
//        System.out.println(artistSearch);
//
//        // Using Collections.sort
//        System.out.println("As it is artist list:");
//        Collections.sort(artistSearch);
//        System.out.println("Ordered artist list:");
//        System.out.println(artistSearch);
//
//        // Using Collections.sort with compareTo as titles have many properties
//        Collections.sort(titleArrayList);
//        System.out.println("After sorting the Title list:");
//        System.out.println(titleArrayList);
//
//        // Using sort with Comparator, comparing and lambda expression as titles must be comparable with numbers
//        System.out.println("Ordering by launch date:");
//        titleArrayList.sort(Comparator.comparing(Title::getLaunchDate));
//        System.out.println(titleArrayList);
    }

}